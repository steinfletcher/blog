import styles from './document.module.css'

<div className={styles["Welcome"]}>

## Idiomatic enums in Go

Go does not have first class support for enumerated types. One way to define an enumerated type is to construct a set of related constants aided by a type alias. Iota may be used to predefine successive incrementing integer constants. We can define a `Color` type like so.

```go
package main

import "fmt"

type Color int

const (
	Red Color = iota // 0
	Blue             // 1
)

func main() {
	var b1 Color = Red
	b1 = Red
	fmt.Println(b1) // prints 0

	var b2 Color = 1
	fmt.Println(b2 == Blue) // prints true

	var b3 Color
	b3 = 42
	fmt.Println(b3)  // prints 42
}

```
 
This pattern is very common in Go code. Whilst being idiomatic the approach has some drawbacks. There is no static type checking since any integer can be passed as a `Color`. There is no serialization support - it's pretty uncommon that a developer will want to serialize this to an integer over the wire or to a database record. There is no support for a readable display value - we'll need to convert the const to a display value in code.

It's important to know the idioms of a language and when to break those idioms. More often than not the argument for idioms is used to shut down arguments. This can sometimes be the death of creativity. 

## Designing an enumerated type

One of Go's best features is its simplicity - developers coming from other languages can generally be efficient in Go very quickly. On the flip side this imposes constraints, such as the lack of generics which can lead to boilerplate code. To overcome some of these shortcomings the community has embraced code generation as a mechanism to define more powerful and flexible types.

Let's use this approach to define an enumerated type. One approach would be to generate an enum as a struct. We can also attach methods to the struct. Structs also support a meta tag which will be useful for defining the display value and description.

```go
type Color struct {
    Red  string `enum:"RED"`
    Blue string `enum:"BLUE"`
}
```

All we need to do now is to generate an instance of the struct for each field.

```go
var Red  = Color{name: "RED"}
var Blue = Color{name: "BLUE"}
```

We can then attach methods to the Color struct to support JSON encoding/decoding. We implement the `Marshaler` interface to support JSON encoding.

```go
func (c Color) MarshalJSON() ([]byte, error) {
    return json.Marshal(c.name)
}
```

Go will invoke our custom implementation when serializing this type as JSON. Likewise we can implement the `Unmarshaler` interface which will enable us to consume enum types - this allows us to define enumerated types directly on data transfer objects in our APIs. 

```go
func (c *Color) UnmarshalJSON(b []byte) error {
   	return json.Unmarshal(b, c.name)
}
```

## Generating code with the ast package and templates

There are a few approaches to generating code. The [Stringer](https://github.com/golang/tools/blob/master/cmd/stringer/stringer.go) tool writes to standard error using the `fmt` package. Whilst this is easy to get going it becomes unwieldy and difficult to debug as the generator scales. A more sane approach is to use the `text/template` package and utilise Go's powerful templating library.

</div>
